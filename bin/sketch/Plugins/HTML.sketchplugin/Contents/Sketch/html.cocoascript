
// - Mark: Utility functions

function runCommand(cmd, path){
	var task = [[NSTask alloc] init];
	task.setLaunchPath("/bin/bash");
	task.setArguments(cmd);
	task.launch();
}

function alertError(msg, title) {
	runCommand(['-c', 'afplay /System/Library/Sounds/Basso.aiff']);
	alert(msg, title);
}

function alert(msg, title) {
	title = title || "Alert";
	var app = [NSApplication sharedApplication];
	[app displayDialog:msg withTitle:title];
}

function exit() {
	throw(nil);
}

function hexColor(color) {
	var r = color.red() * 255;
	var g = color.green() * 255;
	var b = color.blue() * 255;
	return ("#" + r.toString(16) + g.toString(16) + b.toString(16)).toUpperCase();
}

function nameForScale(scale) {
	return (scale > 1) ? "@" + scale + "x" : "";
}

// All logic to export selection to HTML / CSS
function Exporter(context) {
	var context = context;
	var doc = context.document;
	var page = doc.currentPage();
	var selection = doc ? doc.selectedLayers() : nil;
	var selectedArtboards = getSelectedArtboards();

	var imageFormat = "svg";
	var imageScales = [1];
	var embedSvg = false;
	var exportFolder = null;

	this.setOptions = function(options) {
		imageFormat = options.imageFormat;
		embedSvg = options.embedSvg;
		imageScales = options.imageScales;
	}

	// Accessors
	this.getSelection = function() {
		return selection;
	}

	this.getSelectedArtboards = function() {
		return selectedArtboards;
	}

	// Utility functions

	function forEachLayer(group, func) {
		var layers = group.layers();
		for (var i=0; i < layers.count(); i++) {
			func(layers.objectAtIndex(i));
		}
	};

	function forEachChild(group, func) {
		var layers = group.children();
		for (var i=0; i < layers.count(); i++) {
			func(layers.objectAtIndex(i));
		}
	}

	function cleanString(str) {
		return str.replace(/\W+/g, "-");
	}

	function layerMarkedForExport(layer) {
		var exportOptions = layer.exportOptions();
		var formats = exportOptions.exportFormats();
		return formats.count() > 0;
	}

	function saveTextToFile (filename, text) {
		var path = [@"" stringByAppendingString:filename];
		var str = [@"" stringByAppendingString:text];
		str.dataUsingEncoding_(NSUTF8StringEncoding).writeToFile_atomically_(path, true);
	}

	// Gets the artboards belonging to the selected items
	function getSelectedArtboards() {

		// Use set to guarantee unique artboards
		var artboardSet = NSMutableSet.alloc().init();

		var artboards = [];

		for (var i = 0; i < selection.layers().count(); i++) {
			var layer = selection.layers()[i];
			var artboard = layer.parentArtboard();
			if (artboard != undefined && !artboardSet.containsObject(artboard)) {
				artboardSet.addObject(artboard);
				artboards.push(artboard);
			}
		}
		return artboards;
	}

	var exportLayers = {};

	function generateHTML(artboard) {
		// Create new array to save layers for export for each artboard
		exportLayers[artboard] = [];

		// Get HTML & CSS for children
		var childrenHtml = generateHTMLForChildren(artboard, "\t\t\t");

		// Generate HTML
		var html = generateHTMLHeader(artboard);
		html += childrenHtml;
		html += generateHTMLFooter();

		return html;
	}

	function generateCSS(artboard) {
		// Generate CSS
		var css = "/* Generated by Sketch HTML Export */\n";
		css += "\n"

		css += "/* Boiler plate CSS */\n";
		css += "\n";
		css += generateBoilerPlateCSS();
		css += "\n";

		css += "/* Specific to " + artboard.name() + " */\n";
		css += generateCSSForArtboard(artboard);
		css += "\n";

		exportLayers[artboard].forEach(function(layer) {
			css += generateCSSForLayer(layer);
		});

		return css;
	}

	function generateHTMLHeader(artboard) {
		var html = "<html>\n";
		html += "\t<head>\n";
		html += "\t\t<link href='styles.css' rel='stylesheet'>\n";
		html += "\t</head>\n";

		html += "\t<body>\n";
		html += "\t\t<div class='sk-ab sk-" + cleanString(artboard.name()) + "'>\n";

		return html;
	}

	function generateHTMLFooter() {
		var html = "\t\t</div>\n";
		html += "\t</body>\n";
		html += "</html>";

		return html;
	}

	function generateHTMLForChildren(group, tabs) {
		var html = "";

		forEachLayer(group, function(layer) {
			if (!layer.isVisible()) {
				return;
			}

			var openTag = tabs + "<div class='sk-asset sk-" + cleanString(layer.name()) + "'>";
			var closeTag = "</div>\n";

			// If layer is exportable, write it to HTML but not its children
			if (layerMarkedForExport(layer)) {

				// This layer's image needs to be exported
				exportLayers[layer.parentArtboard()].push(layer);

				var embedCode = "";
				if (embedSvg) {
					embedCode = generateSVGString(layer);
				}

				html += openTag + embedCode + closeTag;
			}

			// If layer is group...
			else if (layer instanceof MSLayerGroup) {
				var childrenHtml = generateHTMLForChildren(layer, tabs + "\t");

				// If group is not empty, write it and its children to HTML
				if (childrenHtml != "") {
					html += openTag + "\n";
					html += childrenHtml;
					html += tabs + closeTag;

					// This layer needs to be exported to HTML
					exportLayers[layer.parentArtboard()].push(layer);
				}
			}
		});

		return html;
	}

	function exportImages(layers, exportPath) {
		layers.forEach(function(layer) {
			exportImageForLayer(layer, exportPath + "images/", imageFormat, imageScales);
		});
	}

	function exportImageForLayer(layer, exportPath, imageFormat, imageScales) {
		var filePaths = [];
		var formats = imageScales.map(function(scale) {
			return [MSExportFormat formatWithScale:scale name:nameForScale(scale) fileFormat:imageFormat];
		});
		var requests = [MSExportRequest exportRequestsFromExportableLayer:layer exportFormats:formats useIDForName: false];
		requests.forEach(function(request) {
			var filePath = exportPath + request.name() + "." + request.format();
			filePaths.push(filePath);
			[doc saveExportRequest:request toFile: filePath];
		});
		return filePaths;
	}

	function generateSVGString(layer) {
		var filePaths = exportImageForLayer(layer, exportFolder, "svg", [1]);
		var filePath = filePaths[0];

		var fileUrl = [NSURL fileURLWithPath:filePath];
		var str = [[NSString alloc] initWithContentsOfURL:fileUrl];
		deleteFile(filePath);

		return str;
	}

	function generateCSSForLayer(layer) {
		var css = ".sk-asset.sk-" + cleanString(layer.name()) + " {\n";
		css += "\twidth: " + Math.round(layer.frame().width()) + "px;\n";
		css += "\theight: " + Math.round(layer.frame().height()) + "px;\n";
		css += "\tleft: " + Math.round(layer.frame().x()) + "px;\n";
		css += "\ttop: " + Math.round(layer.frame().y()) + "px;\n";

		// Set background image for exported layer
		if (layerMarkedForExport(layer) && !embedSvg) {
			css += "\tbackground-image: url(\"images/" + layer.name() + "." + imageFormat + "\");\n";
		}

		css += "}\n";
		css += "\n";

		// Set background image for exported layer
		if (layerMarkedForExport(layer) && !embedSvg && imageScales.length > 1) {

			for (var index in imageScales) {
				var scale = imageScales[index];
				if (scale > 1) {
					var appendName = nameForScale(scale);

					css += "@media only screen and (min--moz-device-pixel-ratio: " + scale + "),\n"
					+ "only screen and (-o-min-device-pixel-ratio: " + scale + "/1),\n"
					+ "only screen and (-webkit-min-device-pixel-ratio: " + scale + "),\n"
					+ "only screen and (min-device-pixel-ratio: " + scale + ") {\n";

					css += "\t.sk-asset.sk-" + cleanString(layer.name()) + " {\n";
					css += "\t\tbackground-image: url(\"images/" + layer.name() + appendName + "." + imageFormat + "\");\n";
					css += "\t\tbackground-size: " + Math.round(layer.frame().width()) + "px " + Math.round(layer.frame().height()) + "px;\n";
					css += "\t}\n";

					css += "}\n";
				}
			}
		}

		return css;
	}

	// Generate Header CSS
	function generateBoilerPlateCSS() {
		var css = ".sk-ab {\n"
		+ "\tposition: relative;\n"
		+ "\toverflow: hidden;\n"
		+ "}\n";

		css += "\n";

		css += ".sk-asset {\n"
		+ "\tposition: absolute;\n"
		+ "\tbackground-repeat: no-repeat;\n"
		+ "}\n";

		return css;
	}

	// Generates CSS for just the artboard div
	function generateCSSForArtboard(artboard) {
		var css = ".sk-ab.sk-" + cleanString(artboard.name()) + " {\n";

		if (artboard.hasBackgroundColor) {
			css += "\tbackground-color: " + hexColor(artboard.backgroundColor()) + ";\n";
		}

		css += "\twidth: " + Math.round(artboard.frame().width()) + "px;\n";
		css += "\theight: " + Math.round(artboard.frame().height()) + "px;\n";

		css += "}\n";

		return css;
	}

	this.saveFiles = function(folder) {
		exportFolder = folder;
		selectedArtboards.forEach(function(artboard) {
			var exportPath = exportFolder + artboard.name() + "/";

			deleteFile(exportPath);

			createFolder(exportPath);

			var htmlPath = exportPath + "index.html";
			saveTextToFile(htmlPath, generateHTML(artboard));

			var cssPath = exportPath + "styles.css";
			saveTextToFile(cssPath, generateCSS(artboard));

			if (!embedSvg) {
				createFolder(exportPath + "images/");
				exportImages(exportLayers[artboard], exportPath);
			}
		});
	}
}

function createFolder(name) {
	var fileManager = [NSFileManager defaultManager];
	[fileManager createDirectoryAtPath:name withIntermediateDirectories:true attributes:nil error:nil];
}

function deleteFile(name) {
	var fileManager = [NSFileManager defaultManager];
	[fileManager removeItemAtPath:name error:nil];
}

function fileSaver() {
    // Panel
    var openPanel = [NSOpenPanel openPanel]

    [openPanel setTitle: "Choose a location…"]
    [openPanel setMessage: "Select the export location…"];
    [openPanel setPrompt: "Export"];

    [openPanel setCanCreateDirectories: true]
    [openPanel setCanChooseFiles: false]
    [openPanel setCanChooseDirectories: true]
    [openPanel setAllowsMultipleSelection: false]
    [openPanel setShowsHiddenFiles: false]
    [openPanel setExtensionHidden: false]

    // [openPanel setDirectoryURL:url]

    var openPanelButtonPressed = [openPanel runModal]
    if (openPanelButtonPressed == NSFileHandlingPanelOKButton) {
        return [openPanel URL]
    } else {
		exit();
	}
}

function getOptions(exporter) {

	// Create alert window
	var alert = NSAlert.alloc().init();
	alert.setMessageText("Image Options");
	alert.addButtonWithTitle('Continue');
	alert.addButtonWithTitle('Cancel');

	// Create panel
	var view = NSView.alloc().initWithFrame(NSMakeRect(0, 0, 300, 180));
	alert.setAccessoryView(view);

	// Create a label for image format
    var formatLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 160, 300, 18)];
	[formatLabel setStringValue:"Export images as:"];
	// [formatLabel setFont:[NSFont boldSystemFontOfSize:12]];
	[formatLabel setFont:[NSFont systemFontOfSize:12]];
    [formatLabel setBezeled:false];
    [formatLabel setDrawsBackground:false];
    [formatLabel setEditable:false];
    [formatLabel setSelectable:false];
    [view addSubview:formatLabel];

	// Create radio button array for image format
	var formatButton = NSButtonCell.alloc().init();
    formatButton.setButtonType(NSRadioButton);
    var formatMatrix = [[NSMatrix alloc] initWithFrame:NSMakeRect(0, 110, 300, 40)
                                                  mode:NSRadioModeMatrix
                                             prototype:formatButton
                                          numberOfRows:2
                                      numberOfColumns:1];
    var cellArray = formatMatrix.cells();
    cellArray.objectAtIndex(0).setTitle("png");
    cellArray.objectAtIndex(1).setTitle("svg");
	view.addSubview(formatMatrix);

	// Create view for SVG options
	var svgView = NSView.alloc().initWithFrame(NSMakeRect(0, 20, 300, 70));
	svgView.hidden = true;
	view.addSubview(svgView);

	// Create a label for svg Options
    var svgLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 50, 300, 18)];
	[svgLabel setStringValue:"Export SVG as:"];
	[svgLabel setFont:[NSFont systemFontOfSize:12]];
    [svgLabel setBezeled:false];
    [svgLabel setDrawsBackground:false];
    [svgLabel setEditable:false];
    [svgLabel setSelectable:false];
    [svgView addSubview:svgLabel];

	// Create radio button array for SVG options
	var svgOptionButton = NSButtonCell.alloc().initTextCell("Separate image files");
    svgOptionButton.setButtonType(NSRadioButton);
    var svgMatrix = [[NSMatrix alloc] initWithFrame:NSMakeRect(0, 0, 300, 40)
                                                  mode:NSRadioModeMatrix
                                             prototype:svgOptionButton
                                          numberOfRows:2
                                      numberOfColumns:1];
    cellArray = svgMatrix.cells();
    cellArray.objectAtIndex(0).setTitle("Separate image files");
    cellArray.objectAtIndex(1).setTitle("Embeded in HTML");
	svgView.addSubview(svgMatrix);

	// Create view for PNG options
	var pngView = NSView.alloc().initWithFrame(NSMakeRect(0, 0, 300, 90));
	view.addSubview(pngView);

	// Create a label for png Options
    var pngLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 70, 300, 18)];
	[pngLabel setStringValue:"PNG sizes:"];
	[pngLabel setFont:[NSFont systemFontOfSize:12]];
    [pngLabel setBezeled:false];
    [pngLabel setDrawsBackground:false];
    [pngLabel setEditable:false];
    [pngLabel setSelectable:false];
    [pngView addSubview:pngLabel];

	// Add PNG options
	var pngButton = NSButtonCell.alloc().init();
	pngButton.setTitle("Support Retina Sizes");
	pngButton.setButtonType(NSSwitchButton);
	[pngButton setState:NSOnState];
    var pngMatrix = [[NSMatrix alloc] initWithFrame:NSMakeRect(0, 0, 300, 60)
                                               mode:NSTrackModeMatrix
                                          prototype:pngButton
                                       numberOfRows:3
                                    numberOfColumns:1];
	pngMatrix.setAllowsEmptySelection(true);
	var pngCellArray = pngMatrix.cells();
	pngCellArray.objectAtIndex(0).setTitle("@1x");
	pngCellArray.objectAtIndex(1).setTitle("@2x");
	pngCellArray.objectAtIndex(2).setTitle("@3x");
	pngCellArray.objectAtIndex(0).setEnabled(false);
	pngView.addSubview(pngMatrix);

	// Detect what format is selected and updated UI
	[formatMatrix setCOSJSTargetFunction:function(sender) {
		if (formatMatrix.selectedRow() == 0) { // PNG
			svgView.hidden = true;
			pngView.hidden = false;
		} else { // SVG
			svgView.hidden = false;
			pngView.hidden = true;
		}
	}];
	[formatMatrix setAction:"callAction:"]

	// Display alert
	var responseCode = alert.runModal();

	// Errors or user hit cancel
	if (responseCode != NSAlertFirstButtonReturn) {
		exit();
	}

	// Return options
	var options = {};
	options.imageFormat = formatMatrix.selectedCells()[0].title();
	options.embedSvg = svgMatrix.selectedRow() == 1;
	options.imageScales = [];

	for (var i = 0; i < pngCellArray.count(); i++) {
		var cell = pngCellArray.objectAtIndex(i);
		if (cell.state()) {
			options.imageScales.push(parseInt(cell.title().substring(1)));
		}
	}

	return options;
}

// Called when user runs "Eport HTML"
function exportHTML(context) {
	try {
		var exporter = new Exporter(context);
		var selectedArtboards = exporter.getSelectedArtboards();

		if (selectedArtboards == undefined || selectedArtboards.length < 1) {
			alertError("Please select the artboards you want to export to HTML.", "No Artboard Selected");
			return;
		}

		var options = getOptions();
		exporter.setOptions(options);

		// Open the system dialog to choose the export location
		var fileURL = fileSaver();
		var exportPath = fileURL.path() + "/";

		exporter.saveFiles(exportPath);

	} catch(e) {
		if (e != nil) { // Nil error means plugin was exited
			log(e);
			alert(e, "Error");
		}
	}
}
